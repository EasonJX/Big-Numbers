/* DO NOT EDIT THIS FILE - it is machine generated */
#pragma once

#include <LRparser.h>

const extern ParserTables *SqlTables;

#line 6 "C:\\mytools2015\\Dbase\\SqlParse\\Sql.y"
#include "Sqlsymbol.h"
#include "ParserTree.h"
#include "SqlSymbol.h"
#include "SqlLex.h"

class SqlParser : public LRparser {
private:
  ParserTree &m_tree;
  Date      ttoDate(     const TCHAR *str);
  Time      ttoTime(     const TCHAR *str);
  Timestamp ttoTimestamp(const TCHAR *str);
  SyntaxNodeP m_dollardollar,*m_stacktop,m_userstack[256];
  int   reduceAction(unsigned int prod);
  int   userStackGetHeight() const                { return (int)(m_stacktop - m_userstack); }
  void  userStackInit()		                      { m_stacktop = m_userstack;		     }
  void  userStackShiftSymbol(unsigned int symbol) { m_stacktop++;					     } // push 1 element (garbage) on userstack
  void  userStackPopSymbols(unsigned int count)   { m_stacktop -= count; 			     } // pop count symbols from userstack
  void  userStackShiftDollarDollar()	          { *(++m_stacktop) = m_dollardollar;    } // push($$) on userstack
  void  defaultReduce(unsigned int prod)	      { m_dollardollar  = getStackTop(getProductionLength(prod)?0:1);	 } // $$ = $1
  SyntaxNodeP getStackTop(int fromtop)            { return m_stacktop[-fromtop];         }
  SyntaxNode *newNode( const SourcePosition &pos, int token, ... );
public:
  SqlParser(ParserTree &tree, Scanner *lex = NULL) : LRparser(*SqlTables,lex), m_tree(tree) {
  }
  void      parse( const SourcePosition &pos, const String &stmt); // parse stmt
  void      verror(const SourcePosition &pos, const TCHAR  *format, va_list argptr);
};


#line 18 "C:\\mytools2015\\parsergen\\lib\\parsergencpp.par"

