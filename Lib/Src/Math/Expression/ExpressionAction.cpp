/* DO NOT EDIT THIS FILE - it is machine generated */
#include "pch.h"
#include <Math/Expression/ExpressionParser.h>
#include <Math/MathFunctions.h>

#pragma warning(disable:4312)



int ExpressionParser::reduceAction(unsigned int prod) {

  switch(prod) {
  case 0: /* start -> function */
    { m_tree.setRoot(getStackTop(0));                                       }
    break;
  case 2: /* function -> assignStmtList final_expr */
    { m_dollardollar = newNode( getPos(1), SEMI   , getStackTop(1), getStackTop(0), NULL );         }
    break;
  case 3: /* final_expr -> expr */
    { m_dollardollar = newNode( getPos(1), RETURNREAL, getStackTop(0), NULL );          }
    break;
  case 4: /* final_expr -> boolExpr */
    { m_dollardollar = newNode( getPos(1), RETURNBOOL, getStackTop(0), NULL );          }
    break;
  case 6: /* assignStmtList -> assignStmtList assignStmt */
    { m_dollardollar = newNode( getPos(1), SEMI   , getStackTop(1), getStackTop(0), NULL );         }
    break;
  case 7: /* assignStmt -> assign SEMI */
    { m_dollardollar = getStackTop(1); }
    break;
  case 8: /* assign -> name ASSIGN expr */
    { m_dollardollar = newNode( getPos(2), ASSIGN , getStackTop(2), getStackTop(0), NULL );         }
    break;
  case 9: /* expr -> expr PLUS expr */
    { m_dollardollar = newNode( getPos(2), PLUS   , getStackTop(2), getStackTop(0), NULL);          }
    break;
  case 10: /* expr -> expr MINUS expr */
    { m_dollardollar = newNode( getPos(2), MINUS  , getStackTop(2), getStackTop(0), NULL);          }
    break;
  case 11: /* expr -> expr PROD expr */
    { m_dollardollar = newNode( getPos(2), PROD   , getStackTop(2), getStackTop(0), NULL);          }
    break;
  case 12: /* expr -> expr QUOT expr */
    { m_dollardollar = newNode( getPos(2), QUOT   , getStackTop(2), getStackTop(0), NULL);          }
    break;
  case 13: /* expr -> expr MOD expr */
    { m_dollardollar = newNode( getPos(2), MOD    , getStackTop(2), getStackTop(0), NULL);          }
    break;
  case 14: /* expr -> expr POW expr */
    { m_dollardollar = newNode( getPos(2), POW    , getStackTop(2), getStackTop(0), NULL);          }
    break;
  case 18: /* unary -> function1 LPAR expr RPAR */
    { m_dollardollar = newNode( getStackTop(3)->getPos(),getStackTop(3)->getSymbol(), getStackTop(1), NULL);    }
    break;
  case 19: /* unary -> function2 LPAR expr COMMA expr RPAR */
    { m_dollardollar = newNode( getStackTop(5)->getPos(),getStackTop(5)->getSymbol(), getStackTop(3), getStackTop(1), NULL);}
    break;
  case 20: /* unary -> LPAR expr RPAR */
    { m_dollardollar = getStackTop(1);                                                  }
    break;
  case 21: /* unary -> MINUS expr */
    { m_dollardollar = newNode( getPos(1), MINUS, getStackTop(0), NULL);                }
    break;
  case 22: /* unary -> PLUS expr */
    { m_dollardollar = getStackTop(0);                                                  }
    break;
  case 27: /* unary -> LB boolExpr RB */
    { m_dollardollar = newNode( getPos(1), IIF
    					                                                      , getStackTop(1), newNode(getPos(1), NUMBER  , ator("1"))
    					                                                      , newNode(getPos(1), NUMBER  , ator("0"))
    					                                                      , NULL);                                      }
    break;
  case 28: /* conditionalExpr -> IIF LPAR boolExpr COMMA expr COMMA expr RPAR */
    { m_dollardollar = newNode( getPos(1), IIF, getStackTop(5), getStackTop(3), getStackTop(1), NULL);          }
    break;
  case 29: /* sumExpr -> INDEXEDSUM LPAR assign TO expr RPAR expr */
    { m_dollardollar = newNode( getPos(1), INDEXEDSUM, getStackTop(4), getStackTop(2), getStackTop(0), NULL);   }
    break;
  case 30: /* productExpr -> INDEXEDPRODUCT LPAR assign TO expr RPAR expr */
    { m_dollardollar = newNode( getPos(1), INDEXEDPRODUCT, getStackTop(4), getStackTop(2), getStackTop(0),NULL);}
    break;
  case 31: /* polyExpr -> POLY LB exprList RB LPAR expr RPAR */
    { m_dollardollar = newNode( getPos(1), POLY, getStackTop(4), getStackTop(1), NULL);             }
    break;
  case 32: /* exprList -> exprList COMMA expr */
    { m_dollardollar = newNode( getPos(2), COMMA, getStackTop(2), getStackTop(0), NULL);            }
    break;
  case 34: /* function1 -> ABS */
    { m_dollardollar = newNode( getPos(1), ABS     , NULL);                 }
    break;
  case 35: /* function1 -> ACOS */
    { m_dollardollar = newNode( getPos(1), ACOS    , NULL);                 }
    break;
  case 36: /* function1 -> ACOSH */
    { m_dollardollar = newNode( getPos(1), ACOSH   , NULL);                 }
    break;
  case 37: /* function1 -> ACOT */
    { m_dollardollar = newNode( getPos(1), ACOT    , NULL);                 }
    break;
  case 38: /* function1 -> ACSC */
    { m_dollardollar = newNode( getPos(1), ACSC    , NULL);                 }
    break;
  case 39: /* function1 -> ASEC */
    { m_dollardollar = newNode( getPos(1), ASEC    , NULL);                 }
    break;
  case 40: /* function1 -> ASIN */
    { m_dollardollar = newNode( getPos(1), ASIN    , NULL);                 }
    break;
  case 41: /* function1 -> ASINH */
    { m_dollardollar = newNode( getPos(1), ASINH   , NULL);                 }
    break;
  case 42: /* function1 -> ATAN */
    { m_dollardollar = newNode( getPos(1), ATAN    , NULL);                 }
    break;
  case 43: /* function1 -> ATANH */
    { m_dollardollar = newNode( getPos(1), ATANH   , NULL);                 }
    break;
  case 44: /* function1 -> CEIL */
    { m_dollardollar = newNode( getPos(1), CEIL    , NULL);                 }
    break;
  case 45: /* function1 -> COS */
    { m_dollardollar = newNode( getPos(1), COS     , NULL);                 }
    break;
  case 46: /* function1 -> COSH */
    { m_dollardollar = newNode( getPos(1), COSH    , NULL);                 }
    break;
  case 47: /* function1 -> COT */
    { m_dollardollar = newNode( getPos(1), COT     , NULL);                 }
    break;
  case 48: /* function1 -> CSC */
    { m_dollardollar = newNode( getPos(1), CSC     , NULL);                 }
    break;
  case 49: /* function1 -> ERF */
    { m_dollardollar = newNode( getPos(1), ERF     , NULL);                 }
    break;
  case 50: /* function1 -> EXP */
    { m_dollardollar = newNode( getPos(1), EXP     , NULL);                 }
    break;
  case 51: /* function1 -> FAC */
    { m_dollardollar = newNode( getPos(1), FAC     , NULL);                 }
    break;
  case 52: /* function1 -> FLOOR */
    { m_dollardollar = newNode( getPos(1), FLOOR   , NULL);                 }
    break;
  case 53: /* function1 -> GAMMA */
    { m_dollardollar = newNode( getPos(1), GAMMA   , NULL);                 }
    break;
  case 54: /* function1 -> GAUSS */
    { m_dollardollar = newNode( getPos(1), GAUSS   , NULL);                 }
    break;
  case 55: /* function1 -> INVERF */
    { m_dollardollar = newNode( getPos(1), INVERF  , NULL);                 }
    break;
  case 56: /* function1 -> LN */
    { m_dollardollar = newNode( getPos(1), LN      , NULL);                 }
    break;
  case 57: /* function1 -> LOG10 */
    { m_dollardollar = newNode( getPos(1), LOG10   , NULL);                 }
    break;
  case 58: /* function1 -> NORM */
    { m_dollardollar = newNode( getPos(1), NORM    , NULL);                 }
    break;
  case 59: /* function1 -> PROBIT */
    { m_dollardollar = newNode( getPos(1), PROBIT  , NULL);                 }
    break;
  case 60: /* function1 -> SEC */
    { m_dollardollar = newNode( getPos(1), SEC     , NULL);                 }
    break;
  case 61: /* function1 -> SIGN */
    { m_dollardollar = newNode( getPos(1), SIGN    , NULL);                 }
    break;
  case 62: /* function1 -> SIN */
    { m_dollardollar = newNode( getPos(1), SIN     , NULL);                 }
    break;
  case 63: /* function1 -> SINH */
    { m_dollardollar = newNode( getPos(1), SINH    , NULL);                 }
    break;
  case 64: /* function1 -> SQR */
    { m_dollardollar = newNode( getPos(1), SQR     , NULL);                 }
    break;
  case 65: /* function1 -> SQRT */
    { m_dollardollar = newNode( getPos(1), SQRT    , NULL);                 }
    break;
  case 66: /* function1 -> TAN */
    { m_dollardollar = newNode( getPos(1), TAN     , NULL);                 }
    break;
  case 67: /* function1 -> TANH */
    { m_dollardollar = newNode( getPos(1), TANH    , NULL);                 }
    break;
  case 68: /* boolExpr -> expr EQ expr */
    { m_dollardollar = newNode( getPos(2), EQ      , getStackTop(2), getStackTop(0), NULL);         }
    break;
  case 69: /* boolExpr -> expr NE expr */
    { m_dollardollar = newNode( getPos(2), NE      , getStackTop(2), getStackTop(0), NULL);         }
    break;
  case 70: /* boolExpr -> expr LE expr */
    { m_dollardollar = newNode( getPos(2), LE      , getStackTop(2), getStackTop(0), NULL);         }
    break;
  case 71: /* boolExpr -> expr LT expr */
    { m_dollardollar = newNode( getPos(2), LT      , getStackTop(2), getStackTop(0), NULL);         }
    break;
  case 72: /* boolExpr -> expr GE expr */
    { m_dollardollar = newNode( getPos(2), GE      , getStackTop(2), getStackTop(0), NULL);         }
    break;
  case 73: /* boolExpr -> expr GT expr */
    { m_dollardollar = newNode( getPos(2), GT      , getStackTop(2), getStackTop(0), NULL);         }
    break;
  case 74: /* boolExpr -> boolExpr AND boolExpr */
    { m_dollardollar = newNode( getPos(2), AND     , getStackTop(2), getStackTop(0), NULL);         }
    break;
  case 75: /* boolExpr -> boolExpr OR boolExpr */
    { m_dollardollar = newNode( getPos(2), OR      , getStackTop(2), getStackTop(0), NULL);         }
    break;
  case 76: /* boolExpr -> NOT boolExpr */
    { m_dollardollar = newNode( getPos(2), NOT     , getStackTop(0), NULL);         }
    break;
  case 77: /* boolExpr -> LPAR boolExpr RPAR */
    { m_dollardollar = getStackTop(1);                                                  }
    break;
  case 78: /* function2 -> MAX */
    { m_dollardollar = newNode( getPos(1), MAX     , NULL);                 }
    break;
  case 79: /* function2 -> MIN */
    { m_dollardollar = newNode( getPos(1), MIN     , NULL);                 }
    break;
  case 80: /* function2 -> NORMRAND */
    { m_dollardollar = newNode( getPos(1), NORMRAND, NULL);                 }
    break;
  case 81: /* function2 -> RAND */
    { m_dollardollar = newNode( getPos(1), RAND    , NULL);                 }
    break;
  case 82: /* function2 -> ROOT */
    { m_dollardollar = newNode( getPos(1), ROOT    , NULL);                 }
    break;
  case 83: /* function2 -> BINOMIAL */
    { m_dollardollar = newNode( getPos(1), BINOMIAL, NULL);                 }
    break;
  case 84: /* name -> NAME */
    { m_dollardollar = newNode( getPos(1), NAME    , getText());            }
    break;
  case 85: /* number -> NUMBER */
    { m_dollardollar = newNode( getPos(1), NUMBER  , ttor(getText()));      }
    break;
  }
  return 0;
}

ExpressionNode *ExpressionParser::newNode(const SourcePosition &pos, ExpressionInputSymbol symbol, ...) {
  va_list argptr;
  va_start(argptr, symbol);
  ExpressionNode *p = m_tree.vFetchNode(pos, symbol, argptr);
  va_end(argptr);
  return p;
}

void ExpressionParser::verror(const SourcePosition &pos, const TCHAR *format, va_list argptr) {
  m_tree.vAddError(&pos, format, argptr);
}

