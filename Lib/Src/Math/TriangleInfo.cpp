#include "pch.h"
#include <Math/Triangle/Triangle.h>

// triangleSyntax()   Print list of command line switches
String getTriangleSyntax() {
  String msg;
#ifdef CDT_ONLY
#ifdef REDUCED
  msg += "Triangle [-pAcjevngBPNEIOXzo_lQVh] input_file\n";
#else /* not REDUCED */
  msg += "Triangle [-pAcjevngBPNEIOXzo_iFlCQVh] input_file\n";
#endif /* not REDUCED */
#else /* not CDT_ONLY */
#ifdef REDUCED
  msg += "Triangle [-prq__a__uAcDjevngBPNEIOXzo_YS__lQVh] input_file\n";
#else /* not REDUCED */
  msg += "Triangle [-prq__a__uAcDjevngBPNEIOXzo_YS__iFlsCQVh] input_file\n";
#endif /* not REDUCED */
#endif /* not CDT_ONLY */

  msg += "    -p  Triangulates a Planar Straight Line Graph (.poly file).\n";
#ifndef CDT_ONLY
  msg += "    -r  Refines a previously generated mesh.\n";
  msg +=     "    -q  Quality mesh generation.  A minimum angle may be specified.\n";
  msg += "    -a  Applies a maximum triangle area constraint.\n";
  msg += "    -u  Applies a user-defined triangle constraint.\n";
#endif /* not CDT_ONLY */
  msg +=     "    -A  Applies attributes to identify triangles in certain regions.\n";
  msg += "    -c  Encloses the convex hull with segments.\n";
#ifndef CDT_ONLY
  msg += "    -D  Conforming Delaunay:  all triangles are truly Delaunay.\n";
#endif /* not CDT_ONLY */
/*
  msg += "    -w  Weighted Delaunay triangulation.\n";
  msg += "    -W  Regular triangulation (lower hull of a height field).\n";
*/
  msg += "    -j  Jettison unused vertices from output .node file.\n";
  msg += "    -e  Generates an edge list.\n";
  msg += "    -v  Generates a Voronoi diagram.\n";
  msg += "    -n  Generates a list of triangle neighbors.\n";
  msg += "    -g  Generates an .off file for Geomview.\n";
  msg += "    -B  Suppresses output of boundary information.\n";
  msg += "    -P  Suppresses output of .poly file.\n";
  msg += "    -N  Suppresses output of .node file.\n";
  msg += "    -E  Suppresses output of .ele file.\n";
  msg += "    -I  Suppresses mesh iteration numbers.\n";
  msg += "    -O  Ignores holes in .poly file.\n";
  msg += "    -X  Suppresses use of exact arithmetic.\n";
  msg += "    -z  Numbers all items starting from zero (rather than one).\n";
  msg += "    -o2 Generates second-order subparametric elements.\n";
#ifndef CDT_ONLY
  msg += "    -Y  Suppresses boundary segment splitting.\n";
  msg += "    -S  Specifies maximum number of added Steiner points.\n";
#endif /* not CDT_ONLY */
#ifndef REDUCED
  msg += "    -i  Uses incremental method, rather than divide-and-conquer.\n";
  msg += "    -F  Uses Fortune's sweepline algorithm, rather than d-and-c.\n";
#endif /* not REDUCED */
  msg += "    -l  Uses vertical cuts only, rather than alternating cuts.\n";
#ifndef REDUCED
#ifndef CDT_ONLY
  msg +=     "    -s  Force segments into mesh by splitting (instead of using CDT).\n";
#endif /* not CDT_ONLY */
  msg += "    -C  Check consistency of final mesh.\n";
#endif /* not REDUCED */
  msg += "    -Q  Quiet:  No terminal output except errors.\n";
  msg += "    -V  Verbose:  Detailed information on what I'm doing.\n";
  msg += "    -h  Help:  Detailed instructions for Triangle.\n";
  return msg;
}

// triangleInfo()   Print out complete instructions
String getTriangleInfo() {
  String msg;

  msg += "Triangle\n";
  msg += "A Two-Dimensional Quality Mesh Generator and Delaunay Triangulator.\n";
  msg += "Version 1.6\n\n";
  msg += "Copyright 1993, 1995, 1997, 1998, 2002, 2005 Jonathan Richard Shewchuk\n";
  msg += "2360 Woolsey #H / Berkeley, California 94705-1927\n";
  msg += "Bugs/comments to jrs@cs.berkeley.edu\n";
  msg += "Created as part of the Quake project (tools for earthquake simulation).\n";
  msg += "Supported in part by NSF Grant CMS-9318163 and an NSERC 1967 Scholarship.\n";
  msg += "There is no warranty whatsoever.  Use at your own risk.\n";
#ifdef SINGLE
  msg += "This executable is compiled for single precision arithmetic.\n\n\n";
#else /* not SINGLE */
  msg += "This executable is compiled for double precision arithmetic.\n\n\n";
#endif /* not SINGLE */
  msg += "Triangle generates exact Delaunay triangulations, constrained Delaunay\n";
  msg += "triangulations, conforming Delaunay triangulations, Voronoi diagrams, and\n";
  msg += "high-quality triangular meshes.  The latter can be generated with no small\n";
  msg += "or large angles, and are thus suitable for finite element analysis.  If no\n";
  msg += "command line switch is specified, your .node input file is read, and the\n";
  msg += "Delaunay triangulation is returned in .node and .ele output files.  The\n";
  msg += "command syntax is:\n\n";
  msg += "triangle [-prq__a__uAcDjevngBPNEIOXzo_YS__iFlsCQVh] input_file\n\n";
  msg += "Underscores indicate that numbers may optionally follow certain switches.\n";
  msg += "Do not leave any space between a switch and its numeric parameter.\n";
  msg += "input_file must be a file with extension .node, or extension .poly if the\n";
  msg += "-p switch is used.  If -r is used, you must supply .node and .ele files,\n";
  msg += "and possibly a .poly file and an .area file as well.  The formats of these\n";
  msg += "files are described below.\n\n";
  msg += "Command Line Switches:\n\n";
  msg += "    -p  Reads a Planar Straight Line Graph (.poly file), which can specify\n";
  msg += "        vertices, segments, holes, regional attributes, and regional area\n";
  msg += "        constraints.  Generates a constrained Delaunay triangulation (CDT)\n";
  msg += "        fitting the input; or, if -s, -q, -a, or -u is used, a conforming\n";
  msg += "        constrained Delaunay triangulation (CCDT).  If you want a truly\n";
  msg += "        Delaunay (not just constrained Delaunay) triangulation, use -D as\n";
  msg += "        well.  When -p is not used, Triangle reads a .node file by default.\n";
  msg += "    -r  Refines a previously generated mesh.  The mesh is read from a .node\n";
  msg += "        file and an .ele file.  If -p is also used, a .poly file is read\n";
  msg += "        and used to constrain segments in the mesh.  If -a is also used\n";
  msg += "        (with no number following), an .area file is read and used to\n";
  msg += "        impose area constraints on the mesh.  Further details on refinement\n";
  msg += "        appear below.\n";
  msg += "    -q  Quality mesh generation by Delaunay refinement (a hybrid of Paul\n";
  msg += "        Chew's and Jim Ruppert's algorithms).  Adds vertices to the mesh to\n";
  msg += "        ensure that all angles are between 20 and 140 degrees.  An\n";
  msg += "        alternative bound on the minimum angle, replacing 20 degrees, may\n";
  msg += "        be specified after the `q'.  The specified angle may include a\n";
  msg += "        decimal point, but not exponential notation.  Note that a bound of\n";
  msg += "        theta degrees on the smallest angle also implies a bound of\n";
  msg += "        (180 - 2 theta) on the largest angle.  If the minimum angle is 28.6\n";
  msg += "        degrees or smaller, Triangle is mathematically guaranteed to\n";
  msg += "        terminate (assuming infinite precision arithmetic--Triangle may\n";
  msg += "        fail to terminate if you run out of precision).  In practice,\n";
  msg += "        Triangle often succeeds for minimum angles up to 34 degrees.  For\n";
  msg += "        some meshes, however, you might need to reduce the minimum angle to\n";
  msg += "        avoid problems associated with insufficient floating-point\n";
  msg += "        precision.\n";
  msg += "    -a  Imposes a maximum triangle area.  If a number follows the `a', no\n";
  msg += "        triangle is generated whose area is larger than that number.  If no\n";
  msg += "        number is specified, an .area file (if -r is used) or .poly file\n";
  msg += "        (if -r is not used) specifies a set of maximum area constraints.\n";
  msg += "        An .area file contains a separate area constraint for each\n";
  msg += "        triangle, and is useful for refining a finite element mesh based on\n";
  msg += "        a posteriori error estimates.  A .poly file can optionally contain\n";
  msg += "        an area constraint for each segment-bounded region, thereby\n";
  msg += "        controlling triangle densities in a first triangulation of a PSLG.\n";
  msg += "        You can impose both a fixed area constraint and a varying area\n";
  msg += "        constraint by invoking the -a switch twice, once with and once\n";
  msg += "        without a number following.  Each area specified may include a\n";
  msg += "        decimal point.\n";
  msg += "    -u  Imposes a user-defined constraint on triangle size.  There are two\n";
  msg += "        ways to use this feature.  One is to edit the triunsuitable()\n";
  msg += "        procedure in triangle.c to encode any constraint you like, then\n";
  msg += "        recompile Triangle.  The other is to compile triangle.c with the\n";
  msg += "        EXTERNAL_TEST symbol set (compiler switch -DEXTERNAL_TEST), then\n";
  msg += "        link Triangle with a separate object file that implements\n";
  msg += "        triunsuitable().  In either case, the -u switch causes the user-\n";
  msg += "        defined test to be applied to every triangle.\n";
  msg += "    -A  Assigns an additional floating-point attribute to each triangle\n";
  msg += "        that identifies what segment-bounded region each triangle belongs\n";
  msg += "        to.  Attributes are assigned to regions by the .poly file.  If a\n";
  msg += "        region is not explicitly marked by the .poly file, triangles in\n";
  msg += "        that region are assigned an attribute of zero.  The -A switch has\n";
  msg += "        an effect only when the -p switch is used and the -r switch is not.\n";
  msg += "    -c  Creates segments on the convex hull of the triangulation.  If you\n";
  msg += "        are triangulating a vertex set, this switch causes a .poly file to\n";
  msg += "        be written, containing all edges of the convex hull.  If you are\n";
  msg += "        triangulating a PSLG, this switch specifies that the whole convex\n";
  msg += "        hull of the PSLG should be triangulated, regardless of what\n";
  msg += "        segments the PSLG has.  If you do not use this switch when\n";
  msg += "        triangulating a PSLG, Triangle assumes that you have identified the\n";
  msg += "        region to be triangulated by surrounding it with segments of the\n";
  msg += "        input PSLG.  Beware:  if you are not careful, this switch can cause\n";
  msg += "        the introduction of an extremely thin angle between a PSLG segment\n";
  msg += "        and a convex hull segment, which can cause overrefinement (and\n";
  msg += "        possibly failure if Triangle runs out of precision).  If you are\n";
  msg += "        refining a mesh, the -c switch works differently:  it causes a\n";
  msg += "        .poly file to be written containing the boundary edges of the mesh\n";
  msg += "        (useful if no .poly file was read).\n";
  msg += "    -D  Conforming Delaunay triangulation:  use this switch if you want to\n";
  msg += "        ensure that all the triangles in the mesh are Delaunay, and not\n";
  msg += "        merely constrained Delaunay; or if you want to ensure that all the\n";
  msg += "        Voronoi vertices lie within the triangulation.  (Some finite volume\n";
  msg += "        methods have this requirement.)  This switch invokes Ruppert's\n";
  msg += "        original algorithm, which splits every subsegment whose diametral\n";
  msg += "        circle is encroached.  It usually increases the number of vertices\n";
  msg += "        and triangles.\n";
  msg += "    -j  Jettisons vertices that are not part of the final triangulation\n";
  msg += "        from the output .node file.  By default, Triangle copies all\n";
  msg += "        vertices in the input .node file to the output .node file, in the\n";
  msg += "        same order, so their indices do not change.  The -j switch prevents\n";
  msg += "        duplicated input vertices, or vertices `eaten' by holes, from\n";
  msg += "        appearing in the output .node file.  Thus, if two input vertices\n";
  msg += "        have exactly the same coordinates, only the first appears in the\n";
  msg += "        output.  If any vertices are jettisoned, the vertex numbering in\n";
  msg += "        the output .node file differs from that of the input .node file.\n";
  msg += "    -e  Outputs (to an .edge file) a list of edges of the triangulation.\n";
  msg += "    -v  Outputs the Voronoi diagram associated with the triangulation.\n";
  msg += "        Does not attempt to detect degeneracies, so some Voronoi vertices\n";
  msg += "        may be duplicated.  See the discussion of Voronoi diagrams below.\n";
  msg += "    -n  Outputs (to a .neigh file) a list of triangles neighboring each\n";
  msg += "        triangle.\n";
  msg += "    -g  Outputs the mesh to an Object File Format (.off) file, suitable for\n";
  msg += "        viewing with the Geometry Center's Geomview package.\n";
  msg += "    -B  No boundary markers in the output .node, .poly, and .edge output\n";
  msg += "        files.  See the detailed discussion of boundary markers below.\n";
  msg += "    -P  No output .poly file.  Saves disk space, but you lose the ability\n";
  msg += "        to maintain constraining segments on later refinements of the mesh.\n";
  msg += "    -N  No output .node file.\n";
  msg += "    -E  No output .ele file.\n";
  msg += "    -I  No iteration numbers.  Suppresses the output of .node and .poly\n";
  msg += "        files, so your input files won't be overwritten.  (If your input is\n";
  msg += "        a .poly file only, a .node file is written.)  Cannot be used with\n";
  msg += "        the -r switch, because that would overwrite your input .ele file.\n";
  msg += "        Shouldn't be used with the -q, -a, -u, or -s switch if you are\n";
  msg += "        using a .node file for input, because no .node file is written, so\n";
  msg += "        there is no record of any added Steiner points.\n";
  msg += "    -O  No holes.  Ignores the holes in the .poly file.\n";
  msg += "    -X  No exact arithmetic.  Normally, Triangle uses exact floating-point\n";
  msg += "        arithmetic for certain tests if it thinks the inexact tests are not\n";
  msg += "        accurate enough.  Exact arithmetic ensures the robustness of the\n";
  msg += "        triangulation algorithms, despite floating-point roundoff error.\n";
  msg += "        Disabling exact arithmetic with the -X switch causes a small\n";
  msg += "        improvement in speed and creates the possibility that Triangle will\n";
  msg += "        fail to produce a valid mesh.  Not recommended.\n";
  msg += "    -z  Numbers all items starting from zero (rather than one).  Note that\n";
  msg += "        this switch is normally overridden by the value used to number the\n";
  msg += "        first vertex of the input .node or .poly file.  However, this\n";
  msg += "        switch is useful when calling Triangle from another program.\n";
  msg += "    -o2 Generates second-order subparametric elements with six nodes each.\n";
  msg += "    -Y  No new vertices on the boundary.  This switch is useful when the\n";
  msg += "        mesh boundary must be preserved so that it conforms to some\n";
  msg += "        adjacent mesh.  Be forewarned that you will probably sacrifice much\n";
  msg += "        of the quality of the mesh; Triangle will try, but the resulting\n";
  msg += "        mesh may contain poorly shaped triangles.  Works well if all the\n";
  msg += "        boundary vertices are closely spaced.  Specify this switch twice\n";
  msg += "        (`-YY') to prevent all segment splitting, including internal\n";
  msg += "        boundaries.\n";
  msg += "    -S  Specifies the maximum number of Steiner points (vertices that are\n";
  msg += "        not in the input, but are added to meet the constraints on minimum\n";
  msg += "        angle and maximum area).  The default is to allow an unlimited\n";
  msg += "        number.  If you specify this switch with no number after it,\n";
  msg += "        the limit is set to zero.  Triangle always adds vertices at segment\n";
  msg += "        intersections, even if it needs to use more vertices than the limit\n";
  msg += "        you set.  When Triangle inserts segments by splitting (-s), it\n";
  msg += "        always adds enough vertices to ensure that all the segments of the\n";
  msg += "        PLSG are recovered, ignoring the limit if necessary.\n";
  msg += "    -i  Uses an incremental rather than a divide-and-conquer algorithm to\n";
  msg += "        construct a Delaunay triangulation.  Try it if the divide-and-\n";
  msg += "        conquer algorithm fails.\n";
  msg += "    -F  Uses Steven Fortune's sweepline algorithm to construct a Delaunay\n";
  msg += "        triangulation.  Warning:  does not use exact arithmetic for all\n";
  msg += "        calculations.  An exact result is not guaranteed.\n";
  msg += "    -l  Uses only vertical cuts in the divide-and-conquer algorithm.  By\n";
  msg += "        default, Triangle alternates between vertical and horizontal cuts,\n";
  msg += "        which usually improve the speed except with vertex sets that are\n";
  msg += "        small or short and wide.  This switch is primarily of theoretical\n";
  msg += "        interest.\n";
  msg += "    -s  Specifies that segments should be forced into the triangulation by\n";
  msg += "        recursively splitting them at their midpoints, rather than by\n";
  msg += "        generating a constrained Delaunay triangulation.  Segment splitting\n";
  msg += "        is true to Ruppert's original algorithm, but can create needlessly\n";
  msg += "        small triangles.  This switch is primarily of theoretical interest.\n";
  msg += "    -C  Check the consistency of the final mesh.  Uses exact arithmetic for\n";
  msg += "        checking, even if the -X switch is used.  Useful if you suspect\n";
  msg += "        Triangle is buggy.\n";
  msg += "    -Q  Quiet:  Suppresses all explanation of what Triangle is doing,\n";
  msg += "        unless an error occurs.\n";
  msg += "    -V  Verbose:  Gives detailed information about what Triangle is doing.\n";
  msg += "        Add more `V's for increasing amount of detail.  `-V' is most\n";
  msg += "        useful; itgives information on algorithmic progress and much more\n";
  msg += "        detailed statistics.  `-VV' gives vertex-by-vertex details, and\n";
  msg += "        prints so much that Triangle runs much more slowly.  `-VVVV' gives\n";
  msg += "        information only a debugger could love.\n";
  msg += "    -h  Help:  Displays these instructions.\n";
  msg += "\n";
  msg += "Definitions:\n";
  msg += "\n";
  msg += "  A Delaunay triangulation of a vertex set is a triangulation whose\n";
  msg += "  vertices are the vertex set, that covers the convex hull of the vertex\n";
  msg += "  set.  A Delaunay triangulation has the property that no vertex lies\n";
  msg += "  inside the circumscribing circle (circle that passes through all three\n";
  msg += "  vertices) of any triangle in the triangulation.\n\n";
  msg += "  A Voronoi diagram of a vertex set is a subdivision of the plane into\n";
  msg += "  polygonal cells (some of which may be unbounded, meaning infinitely\n";
  msg += "  large), where each cell is the set of points in the plane that are closer\n";
  msg += "  to some input vertex than to any other input vertex.  The Voronoi diagram\n";
  msg += "  is a geometric dual of the Delaunay triangulation.\n\n";
  msg += "  A Planar Straight Line Graph (PSLG) is a set of vertices and segments.\n";
  msg += "  Segments are simply edges, whose endpoints are all vertices in the PSLG.\n";
  msg += "  Segments may intersect each other only at their endpoints.  The file\n";
  msg += "  format for PSLGs (.poly files) is described below.\n\n";
  msg += "  A constrained Delaunay triangulation (CDT) of a PSLG is similar to a\n";
  msg += "  Delaunay triangulation, but each PSLG segment is present as a single edge\n";
  msg += "  of the CDT.  (A constrained Delaunay triangulation is not truly a\n";
  msg += "  Delaunay triangulation, because some of its triangles might not be\n";
  msg += "  Delaunay.)  By definition, a CDT does not have any vertices other than\n";
  msg += "  those specified in the input PSLG.  Depending on context, a CDT might\n";
  msg += "  cover the convex hull of the PSLG, or it might cover only a segment-\n";
  msg += "  bounded region (e.g. a polygon).\n\n";
  msg += "  A conforming Delaunay triangulation of a PSLG is a triangulation in which\n";
  msg += "  each triangle is truly Delaunay, and each PSLG segment is represented by\n";
  msg += "  a linear contiguous sequence of edges of the triangulation.  New vertices\n";
  msg += "  (not part of the PSLG) may appear, and each input segment may have been\n";
  msg += "  subdivided into shorter edges (subsegments) by these additional vertices.\n";
  msg += "  The new vertices are frequently necessary to maintain the Delaunay\n";
  msg += "  property while ensuring that every segment is represented.\n\n";
  msg += "  A conforming constrained Delaunay triangulation (CCDT) of a PSLG is a\n";
  msg += "  triangulation of a PSLG whose triangles are constrained Delaunay.  New\n";
  msg += "  vertices may appear, and input segments may be subdivided into\n";
  msg += "  subsegments, but not to guarantee that segments are respected; rather, to\n";
  msg += "  improve the quality of the triangles.  The high-quality meshes produced\n";
  msg += "  by the -q switch are usually CCDTs, but can be made conforming Delaunay\n";
  msg += "  with the -D switch.\n\n";
  msg += "File Formats:\n\n";
  msg += "  All files may contain comments prefixed by the character '#'.  Vertices,\n";
  msg += "  triangles, edges, holes, and maximum area constraints must be numbered\n";
  msg += "  consecutively, starting from either 1 or 0.  Whichever you choose, all\n";
  msg += "  input files must be consistent; if the vertices are numbered from 1, so\n";
  msg += "  must be all other objects.  Triangle automatically detects your choice\n";
  msg += "  while reading the .node (or .poly) file.  (When calling Triangle from\n";
  msg += "  another program, use the -z switch if you wish to number objects from\n";
  msg += "  zero.)  Examples of these file formats are given below.\n\n";
  msg += "  .node files:\n";
  msg += "    First line:  <# of vertices> <dimension (must be 2)> <# of attributes>\n";
  msg += "                                           <# of boundary markers (0 or 1)>\n";
  msg += "    Remaining lines:  <vertex #> <x> <y> [attributes] [boundary marker]\n";
  msg += "\n";
  msg += "    The attributes, which are typically floating-point values of physical\n";
  msg += "    quantities (such as mass or conductivity) associated with the nodes of\n";
  msg += "    a finite element mesh, are copied unchanged to the output mesh.  If -q,\n";
  msg += "    -a, -u, -D, or -s is selected, each new Steiner point added to the mesh\n";
  msg += "    has attributes assigned to it by linear interpolation.\n\n";
  msg += "    If the fourth entry of the first line is `1', the last column of the\n";
  msg += "    remainder of the file is assumed to contain boundary markers.  Boundary\n";
  msg += "    markers are used to identify boundary vertices and vertices resting on\n";
  msg += "    PSLG segments; a complete description appears in a section below.  The\n";
  msg += "    .node file produced by Triangle contains boundary markers in the last\n";
  msg += "    column unless they are suppressed by the -B switch.\n\n";
  msg += "  .ele files:\n";
  msg += "    First line:  <# of triangles> <nodes per triangle> <# of attributes>\n";
  msg += "    Remaining lines:  <triangle #> <node> <node> <node> ... [attributes]\n";
  msg += "\n";
  msg += "    Nodes are indices into the corresponding .node file.  The first three\n";
  msg += "    nodes are the corner vertices, and are listed in counterclockwise order\n";
  msg += "    around each triangle.  (The remaining nodes, if any, depend on the type\n";
  msg += "    of finite element used.)\n\n";
  msg += "    The attributes are just like those of .node files.  Because there is no\n";
  msg += "    simple mapping from input to output triangles, Triangle attempts to\n";
  msg += "    interpolate attributes, and may cause a lot of diffusion of attributes\n";
  msg += "    among nearby triangles as the triangulation is refined.  Attributes do\n";
  msg += "    not diffuse across segments, so attributes used to identify\n";
  msg += "    segment-bounded regions remain intact.\n\n";
  msg += "    In .ele files produced by Triangle, each triangular element has three\n";
  msg += "    nodes (vertices) unless the -o2 switch is used, in which case\n";
  msg += "    subparametric quadratic elements with six nodes each are generated.\n";
  msg += "    The first three nodes are the corners in counterclockwise order, and\n";
  msg += "    the fourth, fifth, and sixth nodes lie on the midpoints of the edges\n";
  msg += "    opposite the first, second, and third vertices, respectively.\n";
  msg += "\n";
  msg += "  .poly files:\n";
  msg += "    First line:  <# of vertices> <dimension (must be 2)> <# of attributes>\n";
  msg += "                                           <# of boundary markers (0 or 1)>\n";
  msg += "    Following lines:  <vertex #> <x> <y> [attributes] [boundary marker]\n";
  msg += "    One line:  <# of segments> <# of boundary markers (0 or 1)>\n";
  msg += "    Following lines:  <segment #> <endpoint> <endpoint> [boundary marker]\n";
  msg += "    One line:  <# of holes>\n";
  msg += "    Following lines:  <hole #> <x> <y>\n";
  msg += "    Optional line:  <# of regional attributes and/or area constraints>\n";
  msg += "    Optional following lines:  <region #> <x> <y> <attribute> <max area>\n";
  msg += "\n";
  msg += "    A .poly file represents a PSLG, as well as some additional information.\n";
  msg += "    The first section lists all the vertices, and is identical to the\n";
  msg += "    format of .node files.  <# of vertices> may be set to zero to indicate\n";
  msg += "    that the vertices are listed in a separate .node file; .poly files\n";
  msg += "    produced by Triangle always have this format.  A vertex set represented\n";
  msg += "    this way has the advantage that it may easily be triangulated with or\n";
  msg += "    without segments (depending on whether the -p switch is invoked).\n";
  msg += "\n";
  msg += "    The second section lists the segments.  Segments are edges whose\n";
  msg += "    presence in the triangulation is enforced.  (Depending on the choice of\n";
  msg += "    switches, segment might be subdivided into smaller edges).  Each\n";
  msg += "    segment is specified by listing the indices of its two endpoints.  This\n";
  msg += "    means that you must include its endpoints in the vertex list.  Each\n";
  msg += "    segment, like each point, may have a boundary marker.\n\n";
  msg += "    If -q, -a, -u, and -s are not selected, Triangle produces a constrained\n";
  msg += "    Delaunay triangulation (CDT), in which each segment appears as a single\n";
  msg += "    edge in the triangulation.  If -q, -a, -u, or -s is selected, Triangle\n";
  msg += "    produces a conforming constrained Delaunay triangulation (CCDT), in\n";
  msg += "    which segments may be subdivided into smaller edges.  If -D is\n";
  msg += "    selected, Triangle produces a conforming Delaunay triangulation, so\n";
  msg += "    that every triangle is Delaunay, and not just constrained Delaunay.\n";
  msg += "\n";
  msg += "    The third section lists holes (and concavities, if -c is selected) in\n";
  msg += "    the triangulation.  Holes are specified by identifying a point inside\n";
  msg += "    each hole.  After the triangulation is formed, Triangle creates holes\n";
  msg += "    by eating triangles, spreading out from each hole point until its\n";
  msg += "    progress is blocked by segments in the PSLG.  You must be careful to\n";
  msg += "    enclose each hole in segments, or your whole triangulation might be\n";
  msg += "    eaten away.  If the two triangles abutting a segment are eaten, the\n";
  msg += "    segment itself is also eaten.  Do not place a hole directly on a\n";
  msg += "    segment; if you do, Triangle chooses one side of the segment\n";
  msg += "    arbitrarily.\n\n";
  msg += "    The optional fourth section lists regional attributes (to be assigned\n";
  msg += "    to all triangles in a region) and regional constraints on the maximum\n";
  msg += "    triangle area.  Triangle reads this section only if the -A switch is\n";
  msg += "    used or the -a switch is used without a number following it, and the -r\n";
  msg += "    switch is not used.  Regional attributes and area constraints are\n";
  msg += "    propagated in the same manner as holes:  you specify a point for each\n";
  msg += "    attribute and/or constraint, and the attribute and/or constraint\n";
  msg += "    affects the whole region (bounded by segments) containing the point.\n";
  msg += "    If two values are written on a line after the x and y coordinate, the\n";
  msg += "    first such value is assumed to be a regional attribute (but is only\n";
  msg += "    applied if the -A switch is selected), and the second value is assumed\n";
  msg += "    to be a regional area constraint (but is only applied if the -a switch\n";
  msg += "    is selected).  You may specify just one value after the coordinates,\n";
  msg += "    which can serve as both an attribute and an area constraint, depending\n";
  msg += "    on the choice of switches.  If you are using the -A and -a switches\n";
  msg += "    simultaneously and wish to assign an attribute to some region without\n";
  msg += "    imposing an area constraint, use a negative maximum area.\n\n";
  msg += "    When a triangulation is created from a .poly file, you must either\n";
  msg += "    enclose the entire region to be triangulated in PSLG segments, or\n";
  msg += "    use the -c switch, which automatically creates extra segments that\n";
  msg += "    enclose the convex hull of the PSLG.  If you do not use the -c switch,\n";
  msg += "    Triangle eats all triangles that are not enclosed by segments; if you\n";
  msg += "    are not careful, your whole triangulation may be eaten away.  If you do\n";
  msg += "    use the -c switch, you can still produce concavities by the appropriate\n";
  msg += "    placement of holes just inside the boundary of the convex hull.\n";
  msg += "\n";
  msg += "    An ideal PSLG has no intersecting segments, nor any vertices that lie\n";
  msg += "    upon segments (except, of course, the endpoints of each segment).  You\n";
  msg += "    aren't required to make your .poly files ideal, but you should be aware\n";
  msg += "    of what can go wrong.  Segment intersections are relatively safe--\n";
  msg += "    Triangle calculates the intersection points for you and adds them to\n";
  msg += "    the triangulation--as long as your machine's floating-point precision\n";
  msg += "    doesn't become a problem.  You are tempting the fates if you have three\n";
  msg += "    segments that cross at the same location, and expect Triangle to figure\n";
  msg += "    out where the intersection point is.  Thanks to floating-point roundoff\n";
  msg += "    error, Triangle will probably decide that the three segments intersect\n";
  msg += "    at three different points, and you will find a minuscule triangle in\n";
  msg += "    your output--unless Triangle tries to refine the tiny triangle, uses\n";
  msg += "    up the last bit of machine precision, and fails to terminate at all.\n";
  msg += "    You're better off putting the intersection point in the input files,\n";
  msg += "    and manually breaking up each segment into two.  Similarly, if you\n";
  msg += "    place a vertex at the middle of a segment, and hope that Triangle will\n";
  msg += "    break up the segment at that vertex, you might get lucky.  On the other\n";
  msg += "    hand, Triangle might decide that the vertex doesn't lie precisely on\n";
  msg += "    the segment, and you'll have a needle-sharp triangle in your output--or\n";
  msg += "    a lot of tiny triangles if you're generating a quality mesh.\n";
  msg += "\n";
  msg += "    When Triangle reads a .poly file, it also writes a .poly file, which\n";
  msg += "    includes all the subsegments--the edges that are parts of input\n";
  msg += "    segments.  If the -c switch is used, the output .poly file also\n";
  msg += "    includes all of the edges on the convex hull.  Hence, the output .poly\n";
  msg += "    file is useful for finding edges associated with input segments and for\n";
  msg += "    setting boundary conditions in finite element simulations.  Moreover,\n";
  msg += "    you will need the output .poly file if you plan to refine the output\n";
  msg += "    mesh, and don't want segments to be missing in later triangulations.\n";
  msg += "\n";
  msg += "  .area files:\n";
  msg += "    First line:  <# of triangles>\n";
  msg += "    Following lines:  <triangle #> <maximum area>\n";
  msg += "\n";
  msg += "    An .area file associates with each triangle a maximum area that is used\n";
  msg += "    for mesh refinement.  As with other file formats, every triangle must\n";
  msg += "    be represented, and the triangles must be numbered consecutively.  A\n";
  msg += "    triangle may be left unconstrained by assigning it a negative maximum\n";
  msg += "    area.\n\n";
  msg += "  .edge files:\n";
  msg += "    First line:  <# of edges> <# of boundary markers (0 or 1)>\n";
  msg += "    Following lines:  <edge #> <endpoint> <endpoint> [boundary marker]\n";
  msg += "\n";
  msg += "    Endpoints are indices into the corresponding .node file.  Triangle can\n";
  msg += "    produce .edge files (use the -e switch), but cannot read them.  The\n";
  msg += "    optional column of boundary markers is suppressed by the -B switch.\n";
  msg += "\n";
  msg += "    In Voronoi diagrams, one also finds a special kind of edge that is an\n";
  msg += "    infinite ray with only one endpoint.  For these edges, a different\n";
  msg += "    format is used:\n\n";
  msg += "        <edge #> <endpoint> -1 <direction x> <direction y>\n\n";
  msg += "    The `direction' is a floating-point vector that indicates the direction\n";
  msg += "    of the infinite ray.\n\n";
  msg += "  .neigh files:\n";
  msg += "    First line:  <# of triangles> <# of neighbors per triangle (always 3)>\n";
  msg += "    Following lines:  <triangle #> <neighbor> <neighbor> <neighbor>\n";
  msg += "\n";
  msg += "    Neighbors are indices into the corresponding .ele file.  An index of -1\n";
  msg += "    indicates no neighbor (because the triangle is on an exterior\n";
  msg += "    boundary).  The first neighbor of triangle i is opposite the first\n";
  msg += "    corner of triangle i, and so on.\n\n";
  msg += "    Triangle can produce .neigh files (use the -n switch), but cannot read\n";
  msg += "    them.\n\n";
  msg += "Boundary Markers:\n\n";
  msg += "  Boundary markers are tags used mainly to identify which output vertices\n";
  msg += "  and edges are associated with which PSLG segment, and to identify which\n";
  msg += "  vertices and edges occur on a boundary of the triangulation.  A common\n";
  msg += "  use is to determine where boundary conditions should be applied to a\n";
  msg += "  finite element mesh.  You can prevent boundary markers from being written\n";
  msg += "  into files produced by Triangle by using the -B switch.\n\n";
  msg += "  The boundary marker associated with each segment in an output .poly file\n";
  msg += "  and each edge in an output .edge file is chosen as follows:\n";
  msg += "    - If an output edge is part or all of a PSLG segment with a nonzero\n";
  msg += "      boundary marker, then the edge is assigned the same marker.\n";
  msg += "    - Otherwise, if the edge lies on a boundary of the triangulation\n";
  msg += "      (even the boundary of a hole), then the edge is assigned the marker\n";
  msg += "      one (1).\n";
  msg += "    - Otherwise, the edge is assigned the marker zero (0).\n";
  msg += "  The boundary marker associated with each vertex in an output .node file\n";
  msg += "  is chosen as follows:\n";
  msg += "    - If a vertex is assigned a nonzero boundary marker in the input file,\n";
  msg += "      then it is assigned the same marker in the output .node file.\n";
  msg += "    - Otherwise, if the vertex lies on a PSLG segment (even if it is an\n";
  msg += "      endpoint of the segment) with a nonzero boundary marker, then the\n";
  msg += "      vertex is assigned the same marker.  If the vertex lies on several\n";
  msg += "      such segments, one of the markers is chosen arbitrarily.\n";
  msg += "    - Otherwise, if the vertex occurs on a boundary of the triangulation,\n";
  msg += "      then the vertex is assigned the marker one (1).\n";
  msg += "    - Otherwise, the vertex is assigned the marker zero (0).\n";
  msg += "\n";
  msg += "  If you want Triangle to determine for you which vertices and edges are on\n";
  msg += "  the boundary, assign them the boundary marker zero (or use no markers at\n";
  msg += "  all) in your input files.  In the output files, all boundary vertices,\n";
  msg += "  edges, and segments will be assigned the value one.\n\n";
  msg += "Triangulation Iteration Numbers:\n\n";
  msg += "  Because Triangle can read and refine its own triangulations, input\n";
  msg += "  and output files have iteration numbers.  For instance, Triangle might\n";
  msg += "  read the files mesh.3.node, mesh.3.ele, and mesh.3.poly, refine the\n";
  msg += "  triangulation, and output the files mesh.4.node, mesh.4.ele, and\n";
  msg += "  mesh.4.poly.  Files with no iteration number are treated as if\n";
  msg += "  their iteration number is zero; hence, Triangle might read the file\n";
  msg += "  points.node, triangulate it, and produce the files points.1.node and\n";
  msg += "  points.1.ele.\n\n";
  msg += "  Iteration numbers allow you to create a sequence of successively finer\n";
  msg += "  meshes suitable for multigrid methods.  They also allow you to produce a\n";
  msg += "  sequence of meshes using error estimate-driven mesh refinement.\n";
  msg += "\n";
  msg += "  If you're not using refinement or quality meshing, and you don't like\n";
  msg += "  iteration numbers, use the -I switch to disable them.  This switch also\n";
  msg += "  disables output of .node and .poly files to prevent your input files from\n";
  msg += "  being overwritten.  (If the input is a .poly file that contains its own\n";
  msg += "  points, a .node file is written.  This can be quite convenient for\n";
  msg += "  computing CDTs or quality meshes.)\n\n";
  msg += "Examples of How to Use Triangle:\n\n";
  msg += "  `triangle dots' reads vertices from dots.node, and writes their Delaunay\n";
  msg += "  triangulation to dots.1.node and dots.1.ele.  (dots.1.node is identical\n";
  msg += "  to dots.node.)  `triangle -I dots' writes the triangulation to dots.ele\n";
  msg += "  instead.  (No additional .node file is needed, so none is written.)\n";
  msg += "\n";
  msg += "  `triangle -pe object.1' reads a PSLG from object.1.poly (and possibly\n";
  msg += "  object.1.node, if the vertices are omitted from object.1.poly) and writes\n";
  msg += "  its constrained Delaunay triangulation to object.2.node and object.2.ele.\n";
  msg += "  The segments are copied to object.2.poly, and all edges are written to\n";
  msg += "  object.2.edge.\n\n";
  msg += "  `triangle -pq31.5a.1 object' reads a PSLG from object.poly (and possibly\n";
  msg += "  object.node), generates a mesh whose angles are all between 31.5 and 117\n";
  msg += "  degrees and whose triangles all have areas of 0.1 or less, and writes the\n";
  msg += "  mesh to object.1.node and object.1.ele.  Each segment may be broken up\n";
  msg += "  into multiple subsegments; these are written to object.1.poly.\n";
  msg += "\n";
  msg += "  Here is a sample file `box.poly' describing a square with a square hole:\n";
  msg += "\n";
  msg += "    # A box with eight vertices in 2D, no attributes, one boundary marker.\n";
  msg += "    8 2 0 1\n";
  msg += "     # Outer box has these vertices:\n";
  msg += "     1   0 0   0\n";
  msg += "     2   0 3   0\n";
  msg += "     3   3 0   0\n";
  msg += "     4   3 3   33     # A special marker for this vertex.\n";
  msg += "     # Inner square has these vertices:\n";
  msg += "     5   1 1   0\n";
  msg += "     6   1 2   0\n";
  msg += "     7   2 1   0\n";
  msg += "     8   2 2   0\n";
  msg += "    # Five segments with boundary markers.\n";
  msg += "    5 1\n";
  msg += "     1   1 2   5      # Left side of outer box.\n";
  msg += "     # Square hole has these segments:\n";
  msg += "     2   5 7   0\n";
  msg += "     3   7 8   0\n";
  msg += "     4   8 6   10\n";
  msg += "     5   6 5   0\n";
  msg += "    # One hole in the middle of the inner square.\n";
  msg += "    1\n";
  msg += "     1   1.5 1.5\n";
  msg += "\n";
  msg += "  Note that some segments are missing from the outer square, so you must\n";
  msg += "  use the `-c' switch.  After `triangle -pqc box.poly', here is the output\n";
  msg += "  file `box.1.node', with twelve vertices.  The last four vertices were\n";
  msg += "  added to meet the angle constraint.  Vertices 1, 2, and 9 have markers\n";
  msg += "  from segment 1.  Vertices 6 and 8 have markers from segment 4.  All the\n";
  msg += "  other vertices but 4 have been marked to indicate that they lie on a\n";
  msg += "  boundary.\n\n";
  msg += "    12  2  0  1\n";
  msg += "       1    0   0      5\n";
  msg += "       2    0   3      5\n";
  msg += "       3    3   0      1\n";
  msg += "       4    3   3     33\n";
  msg += "       5    1   1      1\n";
  msg += "       6    1   2     10\n";
  msg += "       7    2   1      1\n";
  msg += "       8    2   2     10\n";
  msg += "       9    0   1.5    5\n";
  msg += "      10    1.5   0    1\n";
  msg += "      11    3   1.5    1\n";
  msg += "      12    1.5   3    1\n";
  msg += "    # Generated by triangle -pqc box.poly\n";
  msg += "\n";
  msg += "  Here is the output file `box.1.ele', with twelve triangles.\n";
  msg += "\n";
  msg += "    12  3  0\n";
  msg += "       1     5   6   9\n";
  msg += "       2    10   3   7\n";
  msg += "       3     6   8  12\n";
  msg += "       4     9   1   5\n";
  msg += "       5     6   2   9\n";
  msg += "       6     7   3  11\n";
  msg += "       7    11   4   8\n";
  msg += "       8     7   5  10\n";
  msg += "       9    12   2   6\n";
  msg += "      10     8   7  11\n";
  msg += "      11     5   1  10\n";
  msg += "      12     8   4  12\n";
  msg += "    # Generated by triangle -pqc box.poly\n\n";
  msg += "  Here is the output file `box.1.poly'.  Note that segments have been added\n";
  msg += "  to represent the convex hull, and some segments have been subdivided by\n";
  msg += "  newly added vertices.  Note also that <# of vertices> is set to zero to\n";
  msg += "  indicate that the vertices should be read from the .node file.\n";
  msg += "\n";
  msg += "    0  2  0  1\n";
  msg += "    12  1\n";
  msg += "       1     1   9     5\n";
  msg += "       2     5   7     1\n";
  msg += "       3     8   7     1\n";
  msg += "       4     6   8    10\n";
  msg += "       5     5   6     1\n";
  msg += "       6     3  10     1\n";
  msg += "       7     4  11     1\n";
  msg += "       8     2  12     1\n";
  msg += "       9     9   2     5\n";
  msg += "      10    10   1     1\n";
  msg += "      11    11   3     1\n";
  msg += "      12    12   4     1\n";
  msg += "    1\n";
  msg += "       1   1.5 1.5\n";
  msg += "    # Generated by triangle -pqc box.poly\n";
  msg += "\n";
  msg += "Refinement and Area Constraints:\n";
  msg += "\n";
  msg += "  The -r switch causes a mesh (.node and .ele files) to be read and\n";
  msg += "  refined.  If the -p switch is also used, a .poly file is read and used to\n";
  msg += "  specify edges that are constrained and cannot be eliminated (although\n";
  msg += "  they can be subdivided into smaller edges) by the refinement process.\n";
  msg += "\n";
  msg += "  When you refine a mesh, you generally want to impose tighter constraints.\n";
  msg += "  One way to accomplish this is to use -q with a larger angle, or -a\n";
  msg += "  followed by a smaller area than you used to generate the mesh you are\n";
  msg += "  refining.  Another way to do this is to create an .area file, which\n";
  msg += "  specifies a maximum area for each triangle, and use the -a switch\n";
  msg += "  (without a number following).  Each triangle's area constraint is applied\n";
  msg += "  to that triangle.  Area constraints tend to diffuse as the mesh is\n";
  msg += "  refined, so if there are large variations in area constraint between\n";
  msg += "  adjacent triangles, you may not get the results you want.  In that case,\n";
  msg += "  consider instead using the -u switch and writing a C procedure that\n";
  msg += "  determines which triangles are too large.\n\n";
  msg += "  If you are refining a mesh composed of linear (three-node) elements, the\n";
  msg += "  output mesh contains all the nodes present in the input mesh, in the same\n";
  msg += "  order, with new nodes added at the end of the .node file.  However, the\n";
  msg += "  refinement is not hierarchical: there is no guarantee that each output\n";
  msg += "  element is contained in a single input element.  Often, an output element\n";
  msg += "  can overlap two or three input elements, and some input edges are not\n";
  msg += "  present in the output mesh.  Hence, a sequence of refined meshes forms a\n";
  msg += "  hierarchy of nodes, but not a hierarchy of elements.  If you refine a\n";
  msg += "  mesh of higher-order elements, the hierarchical property applies only to\n";
  msg += "  the nodes at the corners of an element; the midpoint nodes on each edge\n";
  msg += "  are discarded before the mesh is refined.\n\n";
  msg += "  Maximum area constraints in .poly files operate differently from those in\n";
  msg += "  .area files.  A maximum area in a .poly file applies to the whole\n";
  msg += "  (segment-bounded) region in which a point falls, whereas a maximum area\n";
  msg += "  in an .area file applies to only one triangle.  Area constraints in .poly\n";
  msg += "  files are used only when a mesh is first generated, whereas area\n";
  msg += "  constraints in .area files are used only to refine an existing mesh, and\n";
  msg += "  are typically based on a posteriori error estimates resulting from a\n";
  msg += "  finite element simulation on that mesh.\n\n";
  msg += "  `triangle -rq25 object.1' reads object.1.node and object.1.ele, then\n";
  msg += "  refines the triangulation to enforce a 25 degree minimum angle, and then\n";
  msg += "  writes the refined triangulation to object.2.node and object.2.ele.\n";
  msg += "\n";
  msg += "  `triangle -rpaa6.2 z.3' reads z.3.node, z.3.ele, z.3.poly, and z.3.area.\n";
  msg += "  After reconstructing the mesh and its subsegments, Triangle refines the\n";
  msg += "  mesh so that no triangle has area greater than 6.2, and furthermore the\n";
  msg += "  triangles satisfy the maximum area constraints in z.3.area.  No angle\n";
  msg += "  bound is imposed at all.  The output is written to z.4.node, z.4.ele, and\n";
  msg += "  z.4.poly.\n\n";
  msg += "  The sequence `triangle -qa1 x', `triangle -rqa.3 x.1', `triangle -rqa.1\n";
  msg += "  x.2' creates a sequence of successively finer meshes x.1, x.2, and x.3,\n";
  msg += "  suitable for multigrid.\n\n";
  msg += "Convex Hulls and Mesh Boundaries:\n\n";
  msg += "  If the input is a vertex set (not a PSLG), Triangle produces its convex\n";
  msg += "  hull as a by-product in the output .poly file if you use the -c switch.\n";
  msg += "  There are faster algorithms for finding a two-dimensional convex hull\n";
  msg += "  than triangulation, of course, but this one comes for free.\n\n";
  msg += "  If the input is an unconstrained mesh (you are using the -r switch but\n";
  msg += "  not the -p switch), Triangle produces a list of its boundary edges\n";
  msg += "  (including hole boundaries) as a by-product when you use the -c switch.\n";
  msg += "  If you also use the -p switch, the output .poly file contains all the\n";
  msg += "  segments from the input .poly file as well.\n\n";
  msg += "Voronoi Diagrams:\n\n";
  msg += "  The -v switch produces a Voronoi diagram, in files suffixed .v.node and\n";
  msg += "  .v.edge.  For example, `triangle -v points' reads points.node, produces\n";
  msg += "  its Delaunay triangulation in points.1.node and points.1.ele, and\n";
  msg += "  produces its Voronoi diagram in points.1.v.node and points.1.v.edge.  The\n";
  msg += "  .v.node file contains a list of all Voronoi vertices, and the .v.edge\n";
  msg += "  file contains a list of all Voronoi edges, some of which may be infinite\n";
  msg += "  rays.  (The choice of filenames makes it easy to run the set of Voronoi\n";
  msg += "  vertices through Triangle, if so desired.)\n\n";
  msg += "  This implementation does not use exact arithmetic to compute the Voronoi\n";
  msg += "  vertices, and does not check whether neighboring vertices are identical.\n";
  msg += "  Be forewarned that if the Delaunay triangulation is degenerate or\n";
  msg += "  near-degenerate, the Voronoi diagram may have duplicate vertices or\n";
  msg += "  crossing edges.\n\n";
  msg += "  The result is a valid Voronoi diagram only if Triangle's output is a true\n";
  msg += "  Delaunay triangulation.  The Voronoi output is usually meaningless (and\n";
  msg += "  may contain crossing edges and other pathology) if the output is a CDT or\n";
  msg += "  CCDT, or if it has holes or concavities.  If the triangulated domain is\n";
  msg += "  convex and has no holes, you can use -D switch to force Triangle to\n";
  msg += "  construct a conforming Delaunay triangulation instead of a CCDT, so the\n";
  msg += "  Voronoi diagram will be valid.\n\n";
  msg += "Mesh Topology:\n\n";
  msg += "  You may wish to know which triangles are adjacent to a certain Delaunay\n";
  msg += "  edge in an .edge file, which Voronoi cells are adjacent to a certain\n";
  msg += "  Voronoi edge in a .v.edge file, or which Voronoi cells are adjacent to\n";
  msg += "  each other.  All of this information can be found by cross-referencing\n";
  msg += "  output files with the recollection that the Delaunay triangulation and\n";
  msg += "  the Voronoi diagram are planar duals.\n\n";
  msg += "  Specifically, edge i of an .edge file is the dual of Voronoi edge i of\n";
  msg += "  the corresponding .v.edge file, and is rotated 90 degrees counterclock-\n";
  msg += "  wise from the Voronoi edge.  Triangle j of an .ele file is the dual of\n";
  msg += "  vertex j of the corresponding .v.node file.  Voronoi cell k is the dual\n";
  msg += "  of vertex k of the corresponding .node file.\n\n";
  msg += "  Hence, to find the triangles adjacent to a Delaunay edge, look at the\n";
  msg += "  vertices of the corresponding Voronoi edge.  If the endpoints of a\n";
  msg += "  Voronoi edge are Voronoi vertices 2 and 6 respectively, then triangles 2\n";
  msg += "  and 6 adjoin the left and right sides of the corresponding Delaunay edge,\n";
  msg += "  respectively.  To find the Voronoi cells adjacent to a Voronoi edge, look\n";
  msg += "  at the endpoints of the corresponding Delaunay edge.  If the endpoints of\n";
  msg += "  a Delaunay edge are input vertices 7 and 12, then Voronoi cells 7 and 12\n";
  msg += "  adjoin the right and left sides of the corresponding Voronoi edge,\n";
  msg += "  respectively.  To find which Voronoi cells are adjacent to each other,\n";
  msg += "  just read the list of Delaunay edges.\n\n";
  msg += "  Triangle does not write a list of the edges adjoining each Voronoi cell,\n";
  msg += "  but you can reconstructed it straightforwardly.  For instance, to find\n";
  msg += "  all the edges of Voronoi cell 1, search the output .edge file for every\n";
  msg += "  edge that has input vertex 1 as an endpoint.  The corresponding dual\n";
  msg += "  edges in the output .v.edge file form the boundary of Voronoi cell 1.\n";
  msg += "\n";
  msg += "  For each Voronoi vertex, the .neigh file gives a list of the three\n";
  msg += "  Voronoi vertices attached to it.  You might find this more convenient\n";
  msg += "  than the .v.edge file.\n\n";
  msg += "Quadratic Elements:\n\n";
  msg += "  Triangle generates meshes with subparametric quadratic elements if the\n";
  msg += "  -o2 switch is specified.  Quadratic elements have six nodes per element,\n";
  msg += "  rather than three.  `Subparametric' means that the edges of the triangles\n";
  msg += "  are always straight, so that subparametric quadratic elements are\n";
  msg += "  geometrically identical to linear elements, even though they can be used\n";
  msg += "  with quadratic interpolating functions.  The three extra nodes of an\n";
  msg += "  element fall at the midpoints of the three edges, with the fourth, fifth,\n";
  msg += "  and sixth nodes appearing opposite the first, second, and third corners\n";
  msg += "  respectively.\n\n";
  msg += "Domains with Small Angles:\n\n";
  msg += "  If two input segments adjoin each other at a small angle, clearly the -q\n";
  msg += "  switch cannot remove the small angle.  Moreover, Triangle may have no\n";
  msg += "  choice but to generate additional triangles whose smallest angles are\n";
  msg += "  smaller than the specified bound.  However, these triangles only appear\n";
  msg += "  between input segments separated by small angles.  Moreover, if you\n";
  msg += "  request a minimum angle of theta degrees, Triangle will generally produce\n";
  msg += "  no angle larger than 180 - 2 theta, even if it is forced to compromise on\n";
  msg += "  the minimum angle.\n\n";
  msg += "Statistics:\n\n";
  msg += "  After generating a mesh, Triangle prints a count of entities in the\n";
  msg += "  output mesh, including the number of vertices, triangles, edges, exterior\n";
  msg += "  boundary edges (i.e. subsegments on the boundary of the triangulation,\n";
  msg += "  including hole boundaries), interior boundary edges (i.e. subsegments of\n";
  msg += "  input segments not on the boundary), and total subsegments.  If you've\n";
  msg += "  forgotten the statistics for an existing mesh, run Triangle on that mesh\n";
  msg += "  with the -rNEP switches to read the mesh and print the statistics without\n";
  msg += "  writing any files.  Use -rpNEP if you've got a .poly file for the mesh.\n";
  msg += "\n";
  msg += "  The -V switch produces extended statistics, including a rough estimate\n";
  msg += "  of memory use, the number of calls to geometric predicates, and\n";
  msg += "  histograms of the angles and the aspect ratios of the triangles in the\n";
  msg += "  mesh.\n\n";
  msg += "Exact Arithmetic:\n\n";
  msg += "  Triangle uses adaptive exact arithmetic to perform what computational\n";
  msg += "  geometers call the `orientation' and `incircle' tests.  If the floating-\n";
  msg += "  point arithmetic of your machine conforms to the IEEE 754 standard (as\n";
  msg += "  most workstations do), and does not use extended precision internal\n";
  msg += "  floating-point registers, then your output is guaranteed to be an\n";
  msg += "  absolutely true Delaunay or constrained Delaunay triangulation, roundoff\n";
  msg += "  error notwithstanding.  The word `adaptive' implies that these arithmetic\n";
  msg += "  routines compute the result only to the precision necessary to guarantee\n";
  msg += "  correctness, so they are usually nearly as fast as their approximate\n";
  msg += "  counterparts.\n\n";
  msg += "  May CPUs, including Intel x86 processors, have extended precision\n";
  msg += "  floating-point registers.  These must be reconfigured so their precision\n";
  msg += "  is reduced to memory precision.  Triangle does this if it is compiled\n";
  msg += "  correctly.  See the makefile for details.\n\n";
  msg += "  The exact tests can be disabled with the -X switch.  On most inputs, this\n";
  msg += "  switch reduces the computation time by about eight percent--it's not\n";
  msg += "  worth the risk.  There are rare difficult inputs (having many collinear\n";
  msg += "  and cocircular vertices), however, for which the difference in speed\n";
  msg += "  could be a factor of two.  Be forewarned that these are precisely the\n";
  msg += "  inputs most likely to cause errors if you use the -X switch.  Hence, the\n";
  msg += "  -X switch is not recommended.\n\n";
  msg += "  Unfortunately, the exact tests don't solve every numerical problem.\n";
  msg += "  Exact arithmetic is not used to compute the positions of new vertices,\n";
  msg += "  because the bit complexity of vertex coordinates would grow without\n";
  msg += "  bound.  Hence, segment intersections aren't computed exactly; in very\n";
  msg += "  unusual cases, roundoff error in computing an intersection point might\n";
  msg += "  actually lead to an inverted triangle and an invalid triangulation.\n";
  msg += "  (This is one reason to specify your own intersection points in your .poly\n";
  msg += "  files.)  Similarly, exact arithmetic is not used to compute the vertices\n";
  msg += "  of the Voronoi diagram.\n\n";
  msg += "  Another pair of problems not solved by the exact arithmetic routines is\n";
  msg += "  underflow and overflow.  If Triangle is compiled for double precision\n";
  msg += "  arithmetic, I believe that Triangle's geometric predicates work correctly\n";
  msg += "  if the exponent of every input coordinate falls in the range [-148, 201].\n";
  msg += "  Underflow can silently prevent the orientation and incircle tests from\n";
  msg += "  being performed exactly, while overflow typically causes a floating\n";
  msg += "  exception.\n\n";
  msg += "Calling Triangle from Another Program:\n\n";
  msg += "  Read the file triangle.h for details.\n\n";
  msg += "Troubleshooting:\n\n";
  msg += "  Please read this section before mailing me bugs.\n\n";
  msg += "  `My output mesh has no triangles!'\n\n";
  msg += "    If you're using a PSLG, you've probably failed to specify a proper set\n";
  msg += "    of bounding segments, or forgotten to use the -c switch.  Or you may\n";
  msg += "    have placed a hole badly, thereby eating all your triangles.  To test\n";
  msg += "    these possibilities, try again with the -c and -O switches.\n";
  msg += "    Alternatively, all your input vertices may be collinear, in which case\n";
  msg += "    you can hardly expect to triangulate them.\n\n";
  msg += "  `Triangle doesn't terminate, or just crashes.'\n\n";
  msg += "    Bad things can happen when triangles get so small that the distance\n";
  msg += "    between their vertices isn't much larger than the precision of your\n";
  msg += "    machine's arithmetic.  If you've compiled Triangle for single-precision\n";
  msg += "    arithmetic, you might do better by recompiling it for double-precision.\n";
  msg += "    Then again, you might just have to settle for more lenient constraints\n";
  msg += "    on the minimum angle and the maximum area than you had planned.\n";
  msg += "\n";
  msg += "    You can minimize precision problems by ensuring that the origin lies\n";
  msg += "    inside your vertex set, or even inside the densest part of your\n";
  msg += "    mesh.  If you're triangulating an object whose x-coordinates all fall\n";
  msg += "    between 6247133 and 6247134, you're not leaving much floating-point\n";
  msg += "    precision for Triangle to work with.\n\n";
  msg += "    Precision problems can occur covertly if the input PSLG contains two\n";
  msg += "    segments that meet (or intersect) at an extremely small angle, or if\n";
  msg += "    such an angle is introduced by the -c switch.  If you don't realize\n";
  msg += "    that a tiny angle is being formed, you might never discover why\n";
  msg += "    Triangle is crashing.  To check for this possibility, use the -S switch\n";
  msg += "    (with an appropriate limit on the number of Steiner points, found by\n";
  msg += "    trial-and-error) to stop Triangle early, and view the output .poly file\n";
  msg += "    with Show Me (described below).  Look carefully for regions where dense\n";
  msg += "    clusters of vertices are forming and for small angles between segments.\n";
  msg += "    Zoom in closely, as such segments might look like a single segment from\n";
  msg += "    a distance.\n\n";
  msg += "    If some of the input values are too large, Triangle may suffer a\n";
  msg += "    floating exception due to overflow when attempting to perform an\n";
  msg += "    orientation or incircle test.  (Read the section on exact arithmetic\n";
  msg += "    above.)  Again, I recommend compiling Triangle for double (rather\n";
  msg += "    than single) precision arithmetic.\n\n";
  msg += "    Unexpected problems can arise if you use quality meshing (-q, -a, or\n";
  msg += "    -u) with an input that is not segment-bounded--that is, if your input\n";
  msg += "    is a vertex set, or you're using the -c switch.  If the convex hull of\n";
  msg += "    your input vertices has collinear vertices on its boundary, an input\n";
  msg += "    vertex that you think lies on the convex hull might actually lie just\n";
  msg += "    inside the convex hull.  If so, the vertex and the nearby convex hull\n";
  msg += "    edge form an extremely thin triangle.  When Triangle tries to refine\n";
  msg += "    the mesh to enforce angle and area constraints, Triangle might generate\n";
  msg += "    extremely tiny triangles, or it might fail because of insufficient\n";
  msg += "    floating-point precision.\n\n";
  msg += "  `The numbering of the output vertices doesn't match the input vertices.'\n";
  msg += "\n";
  msg += "    You may have had duplicate input vertices, or you may have eaten some\n";
  msg += "    of your input vertices with a hole, or by placing them outside the area\n";
  msg += "    enclosed by segments.  In any case, you can solve the problem by not\n";
  msg += "    using the -j switch.\n\n";
  msg += "  `Triangle executes without incident, but when I look at the resulting\n";
  msg += "  mesh, it has overlapping triangles or other geometric inconsistencies.'\n";
  msg += "\n";
  msg += "    If you select the -X switch, Triangle occasionally makes mistakes due\n";
  msg += "    to floating-point roundoff error.  Although these errors are rare,\n";
  msg += "    don't use the -X switch.  If you still have problems, please report the\n";
  msg += "    bug.\n\n";
  msg += "  `Triangle executes without incident, but when I look at the resulting\n";
  msg += "  Voronoi diagram, it has overlapping edges or other geometric\n";
  msg += "  inconsistencies.'\n";
  msg += "\n";
  msg += "    If your input is a PSLG (-p), you can only expect a meaningful Voronoi\n";
  msg += "    diagram if the domain you are triangulating is convex and free of\n";
  msg += "    holes, and you use the -D switch to construct a conforming Delaunay\n";
  msg += "    triangulation (instead of a CDT or CCDT).\n\n";
  msg += "  Strange things can happen if you've taken liberties with your PSLG.  Do\n";
  msg += "  you have a vertex lying in the middle of a segment?  Triangle sometimes\n";
  msg += "  copes poorly with that sort of thing.  Do you want to lay out a collinear\n";
  msg += "  row of evenly spaced, segment-connected vertices?  Have you simply\n";
  msg += "  defined one long segment connecting the leftmost vertex to the rightmost\n";
  msg += "  vertex, and a bunch of vertices lying along it?  This method occasionally\n";
  msg += "  works, especially with horizontal and vertical lines, but often it\n";
  msg += "  doesn't, and you'll have to connect each adjacent pair of vertices with a\n";
  msg += "  separate segment.  If you don't like it, tough.\n\n";
  msg += "  Furthermore, if you have segments that intersect other than at their\n";
  msg += "  endpoints, try not to let the intersections fall extremely close to PSLG\n";
  msg += "  vertices or each other.\n\n";
  msg += "  If you have problems refining a triangulation not produced by Triangle:\n";
  msg += "  Are you sure the triangulation is geometrically valid?  Is it formatted\n";
  msg += "  correctly for Triangle?  Are the triangles all listed so the first three\n";
  msg += "  vertices are their corners in counterclockwise order?  Are all of the\n";
  msg += "  triangles constrained Delaunay?  Triangle's Delaunay refinement algorithm\n";
  msg += "  assumes that it starts with a CDT.\n\n";
  msg += "Show Me:\n\n";
  msg += "  Triangle comes with a separate program named `Show Me', whose primary\n";
  msg += "  purpose is to draw meshes on your screen or in PostScript.  Its secondary\n";
  msg += "  purpose is to check the validity of your input files, and do so more\n";
  msg += "  thoroughly than Triangle does.  Unlike Triangle, Show Me requires that\n";
  msg += "  you have the X Windows system.  Sorry, Microsoft Windows users.\n";
  msg += "\n";
  msg += "Triangle on the Web:\n";
  msg += "\n";
  msg += "  To see an illustrated version of these instructions, check out\n";
  msg += "\n";
  msg += "    http://www.cs.cmu.edu/~quake/triangle.html\n";
  msg += "\n";
  msg += "A Brief Plea:\n";
  msg += "\n";
  msg += "  If you use Triangle, and especially if you use it to accomplish real\n";
  msg += "  work, I would like very much to hear from you.  A short letter or email\n";
  msg += "  (to jrs@cs.berkeley.edu) describing how you use Triangle will mean a lot\n";
  msg += "  to me.  The more people I know are using this program, the more easily I\n";
  msg += "  can justify spending time on improvements, which in turn will benefit\n";
  msg += "  you.  Also, I can put you on a list to receive email whenever a new\n";
  msg += "  version of Triangle is available.\n\n";
  msg += "  If you use a mesh generated by Triangle in a publication, please include\n";
  msg += "  an acknowledgment as well.  And please spell Triangle with a capital `T'!\n";
  msg += "  If you want to include a citation, use `Jonathan Richard Shewchuk,\n";
  msg += "  ``Triangle: Engineering a 2D Quality Mesh Generator and Delaunay\n";
  msg += "  Triangulator,'' in Applied Computational Geometry:  Towards Geometric\n";
  msg += "  Engineering (Ming C. Lin and Dinesh Manocha, editors), volume 1148 of\n";
  msg += "  Lecture Notes in Computer Science, pages 203-222, Springer-Verlag,\n";
  msg += "  Berlin, May 1996.  (From the First ACM Workshop on Applied Computational\n";
  msg += "  Geometry.)'\n\n";
  msg += "Research credit:\n\n";
  msg += "  Of course, I can take credit for only a fraction of the ideas that made\n";
  msg += "  this mesh generator possible.  Triangle owes its existence to the efforts\n";
  msg += "  of many fine computational geometers and other researchers, including\n";
  msg += "  Marshall Bern, L. Paul Chew, Kenneth L. Clarkson, Boris Delaunay, Rex A.\n";
  msg += "  Dwyer, David Eppstein, Steven Fortune, Leonidas J. Guibas, Donald E.\n";
  msg += "  Knuth, Charles L. Lawson, Der-Tsai Lee, Gary L. Miller, Ernst P. Mucke,\n";
  msg += "  Steven E. Pav, Douglas M. Priest, Jim Ruppert, Isaac Saias, Bruce J.\n";
  msg += "  Schachter, Micha Sharir, Peter W. Shor, Daniel D. Sleator, Jorge Stolfi,\n";
  msg += "  Robert E. Tarjan, Alper Ungor, Christopher J. Van Wyk, Noel J.\n";
  msg += "  Walkington, and Binhai Zhu.  See the comments at the beginning of the\n";
  msg += "  source code for references.\n\n";
  return msg;
}


