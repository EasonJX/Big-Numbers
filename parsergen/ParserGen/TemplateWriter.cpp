#include "stdafx.h"
#include "TemplateWriter.h"

static TCHAR *dontEditMessage = _T("/* DO NOT EDIT THIS FILE - it is machine generated */");

KeywordTrigger::KeywordTrigger(KeywordHandler &handler, const String &verboseString) : m_handler(handler) {
  m_verboseString = verboseString;
}

TemplateWriter::TemplateWriter(const String &templateName, const String &implOutputDir, const String &headerOutputDir, bool verbose) {
  m_templateName    = templateName;
  m_implOutputDir   = implOutputDir;
  m_headerOutputDir = headerOutputDir;
  m_verbose         = verbose;
  m_output          = NULL;
  openOutput(_T("stdout"));
}

void TemplateWriter::openOutput(const String &name) {
  closeOutput();
  m_output = new MarginFile(name);
}

void TemplateWriter::closeOutput() {
  if(m_output != NULL) {
    delete m_output;
    m_output = NULL;
  }
}

TemplateWriter::~TemplateWriter() {
  closeOutput();
  Iterator<KeywordTrigger*> it = m_keywords.values().getIterator();
  while(it.hasNext()) {
    delete it.next();
  }
}

void TemplateWriter::addKeywordHandler(const String &keyword, KeywordHandler &handler, const String &verboseString) {
  m_keywords.put(keyword, new KeywordTrigger(handler, verboseString));
}

void TemplateWriter::addMacro(const String &macro, const String &value) {
  m_macroes.put(macro, value);
}

String TemplateWriter::getKeyword(const TCHAR *dollar) {
  TCHAR keyword[256];
  int j = 0;
  if(*dollar != '$') {
    throwException(_T("getKeyword:String does not begin with '$' (=<%s>"), dollar);
  }
  for(const TCHAR *cp = dollar+1; *cp && *cp != '$' && j < ARRAYSIZE(keyword)-1; ) {
    keyword[j++] = *(cp++);
  }
  keyword[j++] = '\0';
  return keyword;
}

String TemplateWriter::replaceMacroes(const TCHAR *line) {
  String s = line;
  bool stable;
  do {
    stable = true;
    intptr_t macroLengthInclDollar;
    for(intptr_t dollar = s.find('$'); dollar >= 0; dollar = s.find('$', dollar+macroLengthInclDollar)) {
      String macro = getKeyword(s.cstr() + dollar);
      macroLengthInclDollar = macro.length() + 2;
      String *value = m_macroes.get(macro);
      if(value != NULL) {
        s.remove(dollar, macroLengthInclDollar);
        s.insert(dollar, *value);
        stable = false;
        break;
      }
    }
  } while(!stable);
  return s;
}

void TemplateWriter::generateOutput() {
  FILE *templateFile = FOPEN(m_templateName, _T("r"));
  m_currentPos = SourcePosition(m_templateName, 0, 0);

//  if(m_verbose)
//    printf("Generating %s\n", m_outputName.cstr());

//  m_output->printf("%s\n\n", dontEditMessage);

  TCHAR tmpLine[1024];
  while(FGETS(tmpLine, ARRAYSIZE(tmpLine), templateFile)) {
    m_currentPos.incrLineNumber();
    String line = replaceMacroes(tmpLine);
    bool keywordFound = false;
    for(intptr_t dollar = line.find('$'); dollar >= 0; dollar = line.find('$', dollar+1)) {
      String keyword = getKeyword(line.cstr() + dollar);
      KeywordTrigger **tk = m_keywords.get(keyword);
      if(tk == NULL) {
        continue;
      }

      if(m_verbose && (*tk)->getVerboseString().length() > 0) {
        _tprintf(_T("%s\n"), (*tk)->getVerboseString().cstr());
      }
      m_output->setLeftMargin((int)dollar);
      (*tk)->getHandler().handleKeyword(*this, line);
      keywordFound = true;
      m_output->setLeftMargin(0);
      break;
    }
    if(!keywordFound) {
      m_output->printf(_T("%s\n"), line.cstr());
    }
  }

  fclose(templateFile);
  closeOutput();
}

void writeLineDirective(MarginFile &f, const String &sourceName, int lineNumber) {
  TCHAR tmp[512];
  strReplace(tmp, sourceName.cstr(), _T("\\"), _T("\\\\"));
  int m = f.getLeftMargin();
  f.setLeftMargin(0);
  f.printf(_T("#line %d \"%s\"\n"), lineNumber, tmp);
  f.setLeftMargin(m);
}

void writeSourceText(MarginFile &f, const SourceText &sourceText, const SourcePosition &pos, bool lineDirective) {
  if(lineDirective) {
    writeLineDirective(f, sourceText.m_pos.getFileName(), sourceText.m_pos.getLineNumber());
  }
  f.printf(_T("%s\n"), sourceText.m_sourceText.cstr());
  if(lineDirective) {
    writeLineDirective(f, pos.getFileName(), pos.getLineNumber());
  }
}


SourceTextWriter::SourceTextWriter(const SourceText &sourceText, bool lineDirectives) {
  m_sourceText     = sourceText;
  m_lineDirectives = lineDirectives;
}

void SourceTextWriter::handleKeyword(TemplateWriter &writer, String &line) const {
  ::writeSourceText(writer.getOutput(), m_sourceText, writer.getPos(), m_lineDirectives);
}

void NewFileHandler::handleKeyword(TemplateWriter &writer, String &line) const {
  intptr_t assign = line.find('=');
  if(assign >= 0) {
    String keyword = trim(substr(line, 0, assign));
    String outputDir;
    if(keyword == _T("$NEWFILE$")) {
      outputDir = writer.getImplOutputDir();
    } else {
      outputDir = writer.getHeaderOutputDir();
    }
    String newOutputName = FileNameSplitter::getChildName(trim(outputDir), substr(line, assign+1, line.length()).trim());
    writer.openOutput(newOutputName);
    writer.getOutput().setTrimRight(true);
    writer.getOutput().printf(_T("%s\n"), dontEditMessage);
  }
}
