Vi starter med det simpleste: Uden fastholdelse af ressourcen og uden lukke- eller ugedagskorrektion.
Herudover gives som input også et datoInterval indenfor hvilket den første opgave skal placeres, samt int sammeRessourceIGruppe, der hvis > 0 angiver, for hvilken ressourcegruppe man ønsker at have den samme ressource, f.eks. den samme læge, igennem hele forløbet (Faktisk er parameteren et array, men i nuværende og sandsynligvis i alle fremtidige versioner kan dette array højest indeholde 1 element).
Desuden kan der angives om man ønsker lukkedagskorrektion eller ugedagskorrektion, hvilket betyder, at den indbyrdes afstand mellem opgaverne kan udvides "lidt". Hvis man f.eks. har angivet et forløb med 20 opgaver, hver med en indbyrdes afstand på 1 dag, og der altid er lukket i weekenden, så vil man ikke få noget resultat tilbage, fordi der aldrig kan sammensættes længere opgave-rækker end 5 dage. Med ugedagskorrektion tager SMB hensyn til dette og tillader, at den indbyrdes afstand mellem opgaven om fredagen og mandagen bliver lidt større. Tilsvarende med lukkedagskorrektion, her det blot de enkelte ressourcers planlagte aktiviteter, der afgør om en dag kan betragtes som "weekend". Dvs. hvis en ressource har en hel dag uden planlagte aktiviteter, så vil SMB ved lukkedagskorrektion tillade, at den indbyrdes afstand mellem opgaven umiddelbart før lukkedagen og opgaven umiddelbart efter, kun være 1 større end angivet.
Da det kan være svært at få lavet et helt forløb, specielt lange forløb, uden at overbooke, kan søgemaskinen generere såkaldte blinde tider (blind dates), dvs. en opgave, der kun kan placeres på tidspunkter, hvor en eller flere af de implicerede ressourcer allerede er allokeret til andre opgaver. Generelt vil SMB dog kun returnere blinde tider, hvis der overhovedet ikke findes nogen reelle tider.
Disse 4 features, (fastholdelse af samme ressource, lukke- og ugedagskorrektion og blinde tider)  er i høj grad med til at komplicere programkoden for søgemaskinen.
Søgningen foregår som i SMC i 2 adskilte faser: Først indlæses for hver opgave via SMC de ledige tider i et array, soegeResultat[Antal BFSoegekrav]. Herefter sammensættes de lovlige kombinationer af de indlæste tider, dvs. så den indbyrdes afstand mellem 2 på hinanden følgende opgaver er overholdt. Resultatet af disse kombinationer danner et array af træer, hvor rod-knuderne er resultaterne hørende til første krav, child-knuderne er resultaterne hørende til andet krav, etc. Knuderne i træet har følgende definition:
